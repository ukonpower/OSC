# 音楽シェーダーシステム（Music Shader）

## 概要
このプロジェクトでは、音楽をGLSLシェーダー内で直接生成する独自のシステムを実装しています。`src/ts/Resources/Components/Demo4/Music/shaders/music.vs`が音楽生成の中心となる頂点シェーダーです。

## 仕組み

### 1. 基本アーキテクチャ
- **Transform Feedback**を使用してGPU上で音楽サンプルを生成
- 頂点シェーダーが各サンプル時間に対して左右チャンネルの音声データを出力
- `Music`コンポーネント（`index.ts`）がWebGL2とWeb Audio APIを統合

### 2. 主要パラメータ
- `uBPM`: 100（テンポ）
- `uSampleRate`: オーディオコンテキストのサンプルレート（通常44100Hz）
- `uDuration`: 音楽の総時間（約134.4秒）
- `uTimeOffset`: ブロックごとの時間オフセット

### 3. 音楽構造
音楽は16小節ごとのセクションで構成され、各セクションで異なる楽器やパターンが演奏されます：

```
小節 0-2: イントロ（キック、スネア、howahowa1）
小節 2-6: メインA（ベース、キック、スネア、xylophone、howahowa2、zowaa）
小節 6-8: ブレイク（ベース2、スネア3、キック）
小節 8-9: 間奏（xylophone）
小節 9-12: メインB（ベース、キック、スネア、xylophone、howahowa3、zowaa）
小節 12-13: 終結部（ベース、キック、スネア、xylophone、howahowa3）
小節 13-14: アウトロ（キック、スネア、xylophone）
```

## シェーダー関数リファレンス

### ユーティリティ関数

#### 波形生成
- `ssin(time)`: 正弦波（sin(time * 2π)）
- `saw(time)`: ノコギリ波（fract(-time)*2-1）
- `square(time)`: 矩形波（sign(fract(time)-0.1)）
- `tri(time)`: 三角波
- `whiteNoise(time)`: ホワイトノイズ

#### 音楽制御
- `s2f(scale)`: スケール値を周波数に変換（440Hz基準、半音=1.06倍）
- `beat(time, beat)`: ビート情報を取得（現在位置、カウント、進行度）
- `isin(time, start, end)`: 時間範囲チェック

### 楽器関数

#### 1. ベース (`base1`, `base2`, `base3`)
```glsl
const float baseLine[] = float[](
    10.0, 6.0, 3.0, 5.0, 10.0, 6.0, 3.0, 5.0
);
```
- ベースラインパターンに従った低音シンセサイザー
- 2オクターブ下でサイン波の組み合わせ
- タンジェント関数で歪み効果
- エンベロープでアタック/リリース制御

#### 2. スネア (`snare1`, `snare2`, `snare3`)
- FBMノイズベースのスネアドラム
- 指数関数的減衰エンベロープ
- 3種類のタイミングパターン：
  - `snare1`: 8拍目の7/8位置
  - `snare2`: 2拍目の半分
  - `snare3`: 4拍目の0.725位置

#### 3. キック (`kick1`)
- 低周波数サイン波（s2f(5.0) ≈ 587Hz）
- ピッチベンド効果（-0.05 * exp）
- 短い指数減衰エンベロープ
- 複数のトリガーパターン

#### 4. メロディ (`getMelody`, `zowaa`, `xylophone`)

**メロディ配列**：
```glsl
const float melodyArray[] = float[](
    1.0, 10.0, 13.0,  // パターン1
    3.0, 8.0, 12.0,   // パターン2
    5.0, 10.0, 13.0,  // パターン3
    5.0, 10.0, 13.0,  // パターン4
    3.0, 12.0, 15.0,  // パターン5
    1.0, 10.0, 13.0,  // パターン6
    1.0, 8.0, 12.0,   // パターン7
    3.0, 12.0, 15.0   // パターン8
);
```

**zowaa**:
- 複数のサイン波の組み合わせによる温かい音色
- 位相シフトでステレオ効果
- スムーズなアタック/リリース

**xylophone**:
- 金属的な音色（ピッチベンド効果付き）
- 複数のハーモニクス生成
- LFOによる音色変調

#### 5. アルペジオ (`howahowa1`, `howahowa2`, `howahowa3`)
```glsl
const float howahowaArray[] = float[] (
    -9.0, -6.0, -2.0, 1.0, 5.0, 8.0, 10.0, 13.0, 15.0, 17.0
);
```
- 高速アルペジオパターン
- パンニング効果（左右交互）
- 3種類の異なるパターン進行

## 新しい音楽を作成する方法

### 1. BPMとDURATIONの調整
```typescript
// Music/index.ts
const BPM = 100; // テンポ変更
const MUSIC_DURATION = 60 * ((8 * (28 + 1)) / BPM); // 長さ調整
```

### 2. メロディパターンの変更
```glsl
// 新しいメロディ配列を定義
const float melodyArray[] = float[](
    // 3音ずつのグループで定義（コード構成音）
    0.0, 7.0, 12.0,  // ルート、5度、オクターブ
    // ... 続き
);
```

### 3. ベースラインの変更
```glsl
const float baseLine[] = float[](
    // 8拍のパターン（スケール値）
    0.0, 3.0, 7.0, 5.0, // 新しいベースライン
    // ... 続き
);
```

### 4. 新しい楽器の追加
```glsl
vec2 newInstrument(float mt, float ft, float pitch) {
    vec2 o = vec2(0.0);

    // タイミング制御
    vec4 bt = beat(mt, 4.0);

    // 音生成
    float freq = s2f(pitch);
    o += ssin(ft * freq);

    // エンベロープ
    float env = exp(-bt.z * 5.0);
    o *= env;

    return o * 0.2; // ボリューム調整
}
```

### 5. セクション構成の変更
```glsl
// music関数内で新しいセクションを追加
if(isin(beat16.y, 14.0, 16.0)) {
    // 新しいセクション
    o += newInstrument(mt, t, 0.0);
}
```

## 音楽作成のベストプラクティス

### 1. 音量バランス
- 各楽器の最終出力に適切な係数をかける（0.05〜0.8程度）
- 複数の楽器が同時に鳴る箇所では全体音量に注意

### 2. エンベロープ設計
- アタック: `smoothstep(0.0, 0.001, time)` でクリック音を防ぐ
- サステイン: 持続音は適度な音量に
- リリース: `exp(-time * factor)` で自然な減衰

### 3. ステレオ効果
- 左右で異なる位相: `vec2(0.5, 0.0)` をサイン波に加算
- パンニング: `o.x *= ssin(time); o.y *= ssin(time + PI)`

### 4. 周波数範囲
- ベース: -24〜-12半音（2オクターブ下）
- メロディ: 0〜+12半音（中音域）
- 装飾音: +12〜+24半音（高音域）

### 5. リズムパターン
- `beat()`関数を活用して正確なタイミング制御
- 小節境界を意識した楽器配置
- 変化をつけるため`mod()`でパターン変化

## デバッグのヒント

1. **単一楽器テスト**: `music()`関数で他の楽器をコメントアウト
2. **ビート確認**: クリック音を出してタイミング確認
   ```glsl
   o += step(fract(beat4.x), 0.1) * ssin(t * s2f(12.0)) * 0.1;
   ```
3. **波形確認**: 単純な波形から始めて徐々に複雑化
4. **エンベロープ可視化**: エンベロープ値を音量に直接適用して確認

## パフォーマンス最適化

1. **計算の共通化**: 同じ計算結果は変数に保存
2. **条件分岐最小化**: `isin()`でセクション制御を効率化
3. **ループ展開**: 必要最小限のループ回数に抑える
4. **関数のインライン化**: 小さな関数は展開してオーバーヘッド削減

## 注意事項

- シェーダーは並列処理のため、前のサンプルの値を参照できない
- 複雑な計算はGPUに負荷がかかるため、リアルタイム再生に影響する可能性
- 開発時は`blockLength`を小さくして高速イテレーション
- Transform Feedbackの出力バッファサイズに注意（メモリ制限）
