import * as fs from 'fs';
import * as path from 'path';

import * as chokidar from 'chokidar';
import { Plugin } from 'vite';

let watcher: chokidar.FSWatcher | null = null;

const componentsDir = "./src/resources/Components/";
const outputFile = "./src/app/shaderEditor/_shaderComponents.ts";

interface ShaderFile {
	type: 'vs' | 'fs' | 'glsl';
	relativePath: string; // コンポーネントディレクトリからの相対パス
	fullPath: string; // resources/Components からの相対パス
}

interface ComponentInfo {
	name: string;
	path: string; // resources/Components からの相対パス (index.ts含まず)
	shaders: ShaderFile[];
}

// コンポーネントディレクトリをスキャンして、Meshを持つコンポーネントを検出
const scanShaderComponents = ( isProduction: boolean = false ): ComponentInfo[] => {

	const components: ComponentInfo[] = [];

	const scanDirectory = ( dir: string ) => {

		const files = fs.readdirSync( dir );

		files.forEach( file => {

			const filePath = path.join( dir, file );
			const stat = fs.statSync( filePath );

			if ( stat.isDirectory() ) {

				// プロダクションビルド時は_から始まるディレクトリを除外
				if ( isProduction && file.startsWith( '_' ) ) {

					return;

				}

				scanDirectory( filePath );

			} else if ( stat.isFile() && file === 'index.ts' ) {

				// index.tsを見つけた場合、Meshを追加しているかチェック
				const componentDir = path.dirname( filePath );
				const fileContent = fs.readFileSync( filePath, 'utf-8' );

				// addComponent.*Mesh のパターンでMeshを追加しているか確認
				if ( ! fileContent.match( /addComponent.*Mesh/ ) ) {

					return;

				}

				// shadersディレクトリをチェック
				const shadersDir = path.join( componentDir, 'shaders' );

				if ( ! fs.existsSync( shadersDir ) || ! fs.statSync( shadersDir ).isDirectory() ) {

					return;

				}

				// シェーダーファイルを検出
				const shaderFiles = fs.readdirSync( shadersDir )
					.filter( f => f.endsWith( '.fs' ) || f.endsWith( '.vs' ) || f.endsWith( '.glsl' ) )
					.map( f => {

						const fullPath = path.relative( componentsDir, path.join( shadersDir, f ) ).replace( /\\/g, '/' );
						const ext = path.extname( f ).slice( 1 );
						const type = ext === 'fs' || ext === 'vs' || ext === 'glsl' ? ext as 'fs' | 'vs' | 'glsl' : 'glsl';

						return {
							type,
							relativePath: `shaders/${f}`,
							fullPath
						};

					} );

				if ( shaderFiles.length === 0 ) {

					return;

				}

				// コンポーネントクラス名を取得
				const classMatch = fileContent.match( /export\s+class\s+(\w+)/ );

				if ( classMatch ) {

					const componentName = classMatch[ 1 ];
					const componentPath = path.relative( componentsDir, componentDir ).replace( /\\/g, '/' );

					components.push( {
						name: componentName,
						path: componentPath,
						shaders: shaderFiles
					} );

				}

			}

		} );

	};

	scanDirectory( componentsDir );

	return components;

};

// _shaderComponents.tsファイルを生成
const generateShaderComponentsFile = ( isProduction: boolean = false ) => {

	const components = scanShaderComponents( isProduction );

	let fileContent = "// このファイルは自動生成されます。直接編集しないでください。\n";
	fileContent += "// Generated by ShaderComponentRegistry plugin\n\n";

	// コンポーネントの動的インポート用マッピング
	fileContent += "// コンポーネントの動的インポート用マッピング\n";
	fileContent += "export const COMPONENT_IMPORTS: Record<string, () => Promise<any>> = {\n";

	components.forEach( component => {

		fileContent += `\t"${component.path}": () => import( "~/resources/Components/${component.path}/index.ts" ),\n`;

	} );

	fileContent += "};\n\n";

	// シェーダーファイルの動的インポート用マッピング
	fileContent += "// シェーダーファイルの動的インポート用マッピング\n";
	fileContent += "export const SHADER_IMPORTS: Record<string, () => Promise<any>> = {\n";

	components.forEach( component => {

		component.shaders.forEach( shader => {

			const key = `${component.path}/${shader.relativePath}`;
			fileContent += `\t"${key}": () => import( "~/resources/Components/${shader.fullPath}?raw" ),\n`;

		} );

	} );

	fileContent += "};\n\n";

	// 型定義
	fileContent += "// シェーダーファイル情報\n";
	fileContent += "export interface ShaderFile {\n";
	fileContent += "\ttype: 'vs' | 'fs' | 'glsl';\n";
	fileContent += "\tpath: string; // コンポーネントディレクトリからの相対パス\n";
	fileContent += "}\n\n";

	fileContent += "// シェーダーエディタで編集可能なコンポーネント情報\n";
	fileContent += "export interface ShaderComponent {\n";
	fileContent += "\tname: string;\n";
	fileContent += "\tpath: string;\n";
	fileContent += "\tshaders: ShaderFile[];\n";
	fileContent += "}\n\n";

	// コンポーネント一覧
	fileContent += "export const SHADER_COMPONENTS: ShaderComponent[] = [\n";

	components.forEach( component => {

		fileContent += "\t{\n";
		fileContent += `\t\tname: "${component.name}",\n`;
		fileContent += `\t\tpath: "${component.path}",\n`;
		fileContent += "\t\tshaders: [\n";

		component.shaders.forEach( shader => {

			fileContent += "\t\t\t{\n";
			fileContent += `\t\t\t\ttype: "${shader.type}",\n`;
			fileContent += `\t\t\t\tpath: "${shader.relativePath}"\n`;
			fileContent += "\t\t\t},\n";

		} );

		fileContent += "\t\t]\n";
		fileContent += "\t},\n";

	} );

	fileContent += "];\n";

	// ディレクトリが存在しない場合は作成
	const outputDir = path.dirname( outputFile );
	if ( ! fs.existsSync( outputDir ) ) {

		fs.mkdirSync( outputDir, { recursive: true } );

	}

	fs.writeFileSync( outputFile, fileContent );

	console.log( `[ShaderComponentRegistry] Generated ${outputFile} with ${components.length} components` );

};

export const ShaderComponentRegistry = (): Plugin => {

	let isProduction = false;

	return {
		name: 'ShaderComponentRegistry',
		enforce: 'pre',
		config: ( config, { mode } ) => {

			isProduction = mode === 'production';

			// 初期生成
			generateShaderComponentsFile( isProduction );

		},
		configureServer: ( server ) => {

			if ( watcher !== null ) {

				watcher.close();

			}

			watcher = chokidar.watch( componentsDir, {
				ignored: /[\/\\]\./,
				persistent: true
			} );

			const onChange = ( ) => {

				generateShaderComponentsFile( false );

			};

			watcher.on( 'ready', () => {

				watcher.on( 'add', onChange );
				watcher.on( 'change', onChange );
				watcher.on( 'unlink', onChange );

				watcher.on( 'error', function ( err ) {

					console.log( `[ShaderComponentRegistry] Watcher error: ${err}` );

				} );

			} );

		},
		buildStart: () => {

			console.log( `[ShaderComponentRegistry] buildStart - isProduction: ${isProduction}` );
			generateShaderComponentsFile( isProduction );

		},
		buildEnd: () => {

			if ( watcher ) {

				watcher.close();
				watcher = null;

			}

		},
	};

};
